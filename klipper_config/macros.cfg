#[gcode_macro QUAD_GANTRY_LEVEL]
#rename_existing: BASE_QGL
#gcode:
#    BASE_QGL
#    G1 X280 Y280 F5000

[gcode_macro M140]
rename_existing: M140.1
gcode:
    {% set bed_temp = params.S|float %}
    {% if bed_temp > 100 %}
        SET_FAN_SPEED FAN=exhaust_fan SPEED=1
        SET_FAN_SPEED FAN=nevermore_fan SPEED=0.85
#    {% else %}
#        SET_FAN_SPEED FAN=exhaust_fan SPEED=0
#        SET_FAN_SPEED FAN=nevermore_fan SPEED=0
    {% endif %}
    M117 Bed Temp: {bed_temp}
    M140.1 S{bed_temp}

#[gcode_macro SET_HEATER_TEMPERATURE]
#rename_existing: BASE_SET_HEATER_TEMPERATURE
#gcode:
#    {% set target = params.TARGET %}
#    {% set heater = params.HEATER %}
#    {% if target > 100 and heater == "heater_bed" %}
#        SET_FAN_SPEED FAN=exhaust_fan SPEED=1
#        SET_FAN_SPEED FAN=nevermore_fan SPEED=0.85
#        M117 {heater} {target}
#    {% else %}
#        SET_FAN_SPEED FAN=exhaust_fan SPEED=0
#        SET_FAN_SPEED FAN=nevermore_fan SPEED=0
#    {% endif %}
#    BASE_SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET=100

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BED_MESH_CALIBRATE
gcode:
    {% set mesh_min = params.MESH_MIN %}
    {% set mesh_max = params.MESH_MAX %}
    {% set probe_count = params.PROBE_COUNT %}
    {% set rRefIndex = params.RELATIVE_REFERENCE_INDEX %}
    {% set algo = params.ALGORITHM %}
    M117 Bed mesh
    ATTACH_PROBE
    _BED_MESH_CALIBRATE MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} RELATIVE_REFERENCE_INDEX={rRefIndex} ALGORITHM={algo}
    DOCK_PROBE
    M117

[gcode_macro PROBE_SPEED]
gcode:
    ATTACH_PROBE_LOCK
    G1 X150 Y150 F4000
    PROBE_ACCURACY SAMPLES=20 PROBE_SPEED=3
    PROBE_ACCURACY SAMPLES=20 PROBE_SPEED=6
    PROBE_ACCURACY SAMPLES=20 PROBE_SPEED=9
    PROBE_ACCURACY SAMPLES=20 PROBE_SPEED=12
    PROBE_ACCURACY SAMPLES=20 PROBE_SPEED=15
    DOCK_PROBE_UNLOCK

[gcode_macro G32]
gcode:
    BED_MESH_CLEAR
    G28 XYZ
    QUAD_GANTRY_LEVEL
    G28 Z
    G1 Y275 F1500 #to avoid probe if clean_nozzle after

[gcode_macro M600]
gcode:
    M117 Filament change
    PAUSE

[gcode_macro PRINT_END]
#   Use PRINT_END for the slicer ending script - please customise for your slicer of choice
gcode:
#    M400                           ; wait for buffer to clear
#    G92 E0                         ; zero the extruder
#    G1 E-10.0 F3600                ; retract filament
#    G91                            ; relative positioning
#    G0 Z1.00 X20.0 Y20.0 F20000    ; move nozzle to remove stringing
#    TURN_OFF_HEATERS
#    M107                           ; turn off fan
#    G1 Z2 F3000                    ; move nozzle up 2mm
#    G90                            ; absolute positioning
#    G0  X125 Y250 F3600            ; park nozzle at rear
#    BED_MESH_CLEAR

    M117 Ending Print
    M400
    PARK E=10
    M107
    BED_MESH_CLEAR
    M84

    # Filter the air at full power for 10min before stopping everything
    SET_FAN_SPEED FAN=exhaust_fan SPEED=1
    G4 P{60000 * 10}
    SET_FAN_SPEED FAN=exhaust_fan SPEED=0


[gcode_macro ADAPTIVE_BED_MESH]
# You need to add in SuperSlicer custom Gcode the first layer size as following and then call this macro with it:
# SIZE={first_layer_print_min[0]}_{first_layer_print_min[1]}_{first_layer_print_max[0]}_{first_layer_print_max[1]}
gcode:
    # 1 ----- GET ORIGINAL BEDMESH PARAMS FROM CONFIG ----------------------
    {% set xMinConf, yMinConf = printer["configfile"].config["bed_mesh"]["mesh_min"].split(',')|map('trim')|map('int') %}
    {% set xMaxConf, yMaxConf = printer["configfile"].config["bed_mesh"]["mesh_max"].split(',')|map('trim')|map('int') %}
    {% set xProbeCntConf, yProbeCntConf = printer["configfile"].config["bed_mesh"]["probe_count"].split(',')|map('trim')|map('int') %}
    {% set algo = printer["configfile"].config["bed_mesh"]["algorithm"] %}
    {% set xMeshPPS, yMeshPPS = printer["configfile"].config["bed_mesh"]["mesh_pps"].split(',')|map('trim')|map('int') %}

    # If the SIZE parameter is defined and set not a dummy placeholder, we do the adaptive
    # bed mesh logic. If it's ommited, we still do the original BED_MESH_CALIBRATE function
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}

        # 2 ----- GET MESH SIZE AND MARGIN FROM MACRO CALL --------------------
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set margin = params.MARGIN|default(5)|int %}

        # 3 ----- APPLY MARGINS ----------------------------------------------
        # We use min/max function as we want it to be constrained by the original
        # bedmesh size. This will avoid going outside the machine limits
        {% set xMin = [xMinConf, (xMinSpec - margin)]|max %}
        {% set xMax = [xMaxConf, (xMaxSpec + margin)]|min %}
        {% set yMin = [yMinConf, (yMinSpec - margin)]|max %}
        {% set yMax = [yMaxConf, (yMaxSpec + margin)]|min %}

        # 4 ----- COMPUTE A NEW PROBE COUNT ----------------------------------
        # The goal is to have at least the same precision as from the config. So we compute an equivalent number
        # of probe points on each X/Y dimensions (distance between two points should be the same as in the config)
        {% set xProbeCnt = ((xMax - xMin) * xProbeCntConf / (xMaxConf - xMinConf))|round(0, 'ceil')|int %}
        {% set yProbeCnt = ((yMax - yMin) * yProbeCntConf / (yMaxConf - yMinConf))|round(0, 'ceil')|int %}

        # Then, three possibilities :
        # a) Both dimensions have less than 3 probe points : the bed_mesh is not needed as it's a small print.
        # b) If one of the dimension is less than 3 and the other is greater. The print looks to be elongated and
        #    need the adaptive bed_mesh : we add probe points to the small direction to reach 3 and be able to do it.
        # c) If both direction are greater than 3, we need the adaptive bed_mesh and it's ok.
        # At the end we control (according to Klipper bed_mesh method: "_verify_algorithm") that the computed probe_count is
        # valid according to the choosen algorithm or change it if needed.
        {% if xProbeCnt < 3 and yProbeCnt < 3 %}
            RESPOND MSG="Adaptive bed mesh: mesh not needed"
            
        {% else %}
            {% set xProbeCnt = [3, xProbeCnt]|max %}
            {% set yProbeCnt = [3, yProbeCnt]|max %}

            # We verify that the number of probe points on each axis is odd or add
            # one to it. This is to have a relative_reference_index point at the center of the mesh
            {% if xProbeCnt % 2 == 0 %}
                {% set xProbeCnt = xProbeCnt + 1 %}
            {% endif %}
            {% if yProbeCnt % 2 == 0 %}
                {% set yProbeCnt = yProbeCnt + 1 %}
            {% endif %}

            # Check of the probe points and interpolation algorithms according to Klipper code
            {% if xMeshPPS != 0 or yMeshPPS != 0 %}
                {% set probeCntMin = [xProbeCnt, yProbeCnt]|min %}
                {% set probeCntMax = [xProbeCnt, yProbeCnt]|max %}
                {% if algo == "lagrange" and probeCntMax > 6 %}
                    # Lagrange interpolation tends to oscillate when using more than 6 samples: swith to bicubic
                    {% set algo = "bicubic" %}
                {% endif %}
                {% if algo == "bicubic" and probeCntMin < 4 %}
                    {% if probeCntMax > 6 %}
                        # Impossible case: need to add probe point on the small axis to be >= 4 (we want 5 to keep it odd)
                        {% if xProbeCnt > yProbeCnt %}
                            {% set yProbeCnt = 5 %}
                        {% else %}
                            {% set xProbeCnt = 5 %}
                        {% endif %}
                    {% else %}
                        # In this case bicubic is not adapted (less than 4 points): switch to lagrange
                        {% set algo = "lagrange" %}
                    {% endif %}
                {% endif %}
            {% endif %}

            # 5 ----- COMPUTE THE RELATIVE_REFERENCE_INDEX POINT --------------------
            {% set rRefIndex = (((xProbeCnt * yProbeCnt) - 1) / 2)|int %}

            # 6 ----- FORMAT THE PARAMETERS TO CALL BED_MESH_CALIBRATE --------------
            {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
            {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
            {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
            RESPOND MSG="Adaptive bed mesh: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} RELATIVE_REFERENCE_INDEX={rRefIndex} ALGORITHM={algo}"
            BED_MESH_CALIBRATE MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} RELATIVE_REFERENCE_INDEX={rRefIndex} ALGORITHM={algo}
        {% endif %}
    {% else %}
        RESPOND MSG="Adaptive bed mesh: nominal bed mesh"
        BED_MESH_CALIBRATE
    {% endif %}

[gcode_macro PARK]
description: Park the toolhead at the back and retract some filament if the nozzle is hot
gcode:
    {% set E = params.E|default(1.7)|float %}

    {% set x_park = printer.toolhead.axis_minimum.x|float + 150.0 %}
    {% set y_park = printer.toolhead.axis_maximum.y|float - 30.0 %}
    {% set max_z = printer.toolhead.axis_maximum.z|float %}

    {% set St = printer["gcode_macro Ibax_Variables"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro Ibax_Variables"].z_drop_speed * 60 %}

    {% set act_z = printer.toolhead.position.z|float %}
    {% if act_z < (max_z - 50.0) %}
        {% set z_safe = 50.0 %}
    {% else %}
        {% set z_safe = max_z - act_z %}
    {% endif %}

    {% if printer.extruder.temperature > 185 %}
        G1 E-{E} F2100
    {% endif %}

    G91    
    G1 Z{z_safe} F{Sz}
    G90
    G0 X{x_park} Y{y_park} F{St}
    G91

[gcode_macro CANCEL_PRINT]
rename_existing: BASE_CANCEL_PRINT
description: Cancel the print, retract 10mm of filament and park
gcode:
    M400
    PARK E=10
    TURN_OFF_HEATERS
    M107
    CLEAR_PAUSE
    BED_MESH_CLEAR
    SDCARD_RESET_FILE
    #SET_FAN_SPEED FAN=filter SPEED=0
    BASE_CANCEL_PRINT

[gcode_macro PAUSE]
rename_existing: BASE_PAUSE
description: Pause the print and park
gcode:
    SAVE_GCODE_STATE NAME=PAUSE_state
    BASE_PAUSE
    PARK

[gcode_macro RESUME]
rename_existing: BASE_RESUME
description: Resume the print after an optional unretract
gcode:
    {% set E = params.E|default(1.7)|float %}

    G1 E{E} F2100
    RESTORE_GCODE_STATE NAME=PAUSE_state
    BASE_RESUME